the same and every node is at least half full we are guaranteed that the asymptotic performance is Olg n where n is the size of the collection The real win is in the constant factors of course We can choose m so that the pointers to the m children plus the mâˆ’1 elements fill out a cache line at the highest level of the memory hierarchy where we can expect to get cache hits For example if we are accessing a large disk database then our cache lines are memory blocks of the size that is read from disk Lookup in a Btree is straightforward Given a node to start from we use a simple linear or binary search to find whether the desired element is in the node or if not which child31425 442 PM Btrees httpswwwcscornelleducoursescs31102012sprecitationsrec25Btreesrec25html 13pointer to follow from the current node Insertion and deletion from a Btree are more complicated in fact they are notoriously difficult to implement correctly For insertion we first find the appropriate leaf node into which the