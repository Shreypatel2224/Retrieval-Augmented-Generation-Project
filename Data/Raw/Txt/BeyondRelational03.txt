Benefits of the Relational Model

- Mostly Standard Data Model and Query Language
- ACID Compliance (Atomicity, Consistency, Isolation, Durability)
- Works well with highly structured data
- Can handle large amounts of data
- Well understood, with lots of tooling and experience

Relational Database Performance

Many ways that an RDBMS increases efficiency:
- Indexing (the topic we focused on)
- Directly controlling storage
- Column-oriented storage vs row-oriented storage
- Query optimization
- Caching/prefetching
- Materialized views
- Precompiled stored procedures
- Data replication and partitioning

Transaction Processing

- Transaction: A sequence of one or more CRUD operations performed as a single, logical unit of work.
  - Either the entire sequence succeeds (COMMIT)
  - OR the entire sequence fails (ROLLBACK or ABORT)
- Helps ensure:
  - Data Integrity
  - Error Recovery
  - Concurrency Control
  - Reliable Data Storage
  - Simplified Error Handling

ACID Properties

- Atomicity:
  - A transaction is treated as an atomic unit - it is fully executed or no parts of it are executed.
- Consistency:
  - A transaction takes a database from one consistent state to another consistent state.
  - Consistent state: All data meets integrity constraints.
- Isolation:
  - Two transactions T1 and T2 are executed at the same time but cannot affect each other.
    - If both T1 and T2 are reading the data - no problem.
    - If T1 is reading the same data that T2 may be writing, it can result in:
      - Dirty Read
      - Non-repeatable Read
      - Phantom Reads
- Durability:
  - Once a transaction is completed and committed successfully, its changes are permanent.
  - Even in the event of a system failure, committed transactions are preserved.

Isolation Issues

- Dirty Read:
  - A transaction T1 is able to read a row that has been modified by another transaction T2 that hasn’t yet executed a COMMIT.
- Non-repeatable Read:
  - Two queries in a single transaction T1 execute a SELECT but get different values because another transaction T2 has changed data and COMMITTED.
- Phantom Reads:
  - When a transaction T1 is running and another transaction T2 adds or deletes rows from the set T1 is using.

Example Transaction - Transfer Money

DELIMITER //

CREATE PROCEDURE transfer(
    IN sender_id INT,
    IN receiver_id INT,
    IN amount DECIMAL(10,2)
BEGIN
    DECLARE rollback_message VARCHAR(255) DEFAULT 'Transaction rolled back: Insufficient funds';
    DECLARE commit_message VARCHAR(255) DEFAULT 'Transaction committed successfully';

    -- Start the transaction
    START TRANSACTION;

    -- Attempt to debit money from account 1
    UPDATE accounts SET balance = balance - amount WHERE account_id = sender_id;

    -- Attempt to credit money to account 2
    UPDATE accounts SET balance = balance + amount WHERE account_id = receiver_id;

    -- Check if there are sufficient funds in account 1
    IF (SELECT balance FROM accounts WHERE account_id = sender_id) < 0 THEN
        -- Roll back the transaction if there are insufficient funds
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = rollback_message;
    ELSE
        -- Log the transactions if there are sufficient funds
        INSERT INTO transactions (account_id, amount, transaction_type) VALUES (sender_id, -amount, 'WITHDRAWAL');
        INSERT INTO transactions (account_id, amount, transaction_type) VALUES (receiver_id, amount, 'DEPOSIT');
        
        -- Commit the transaction
        COMMIT;
        SELECT commit_message AS 'Result';
    END IF;
END //

DELIMITER ;

Limitations of Relational Databases

- Schemas may evolve over time.
- Not all apps need the full strength of ACID compliance.
- Joins can be expensive.
- A lot of data is semi-structured or unstructured (e.g., JSON, XML).
- Horizontal scaling presents challenges.
- Some apps need something more performant (e.g., real-time, low-latency systems).

Scalability - Up or Out?

- Conventional Wisdom: Scale vertically (up, with bigger, more powerful systems) until the demands of high-availability make it necessary to scale out with some type of distributed computing model.
- Why? Scaling up is easier - no need to modify your architecture. But there are practical and financial limits.
- However: Modern systems make horizontal scaling less problematic.

Distributed Systems

- A distributed system is “a collection of independent computers that appear to its users as one computer.” - Andrew Tannenbaum
- Characteristics of Distributed Systems:
  - Computers operate concurrently.
  - Computers fail independently.
  - No shared global clock.

Distributed Storage

- Distributed Data Stores:
  - Data is stored on more than one node, typically replicated.
  - Each block of data is available on N nodes.
  - Distributed databases can be relational or non-relational.
    - MySQL and PostgreSQL support replication and sharding.
    - CockroachDB is a new player on the scene.
    - Many NoSQL systems support one or both models.
- Network partitioning is inevitable:
  - Network failures, system failures.
  - Overall system needs to be Partition Tolerant.
  - The system can keep running even with a network partition.

The CAP Theorem

- The CAP Theorem states that it is impossible for a distributed data store to simultaneously provide more than two out of the following three guarantees:
  - Consistency: Every read receives the most recent write or an error.
  - Availability: Every request receives a (non-error) response, but no guarantee that the response contains the most recent write.
  - Partition Tolerance: The system can continue to operate despite arbitrary network issues.

CAP Theorem - Database View

- Consistency*: Every user of the DB has an identical view of the data at any given instant.
- Availability: In the event of a failure, the database remains operational.
- Partition Tolerance: The database can maintain operations in the event of the network’s failing between two segments of the distributed system.
  - *Note: The definition of Consistency in CAP is different from that of ACID.

CAP Theorem - Database View (Continued)

- Consistency + Availability:
  - The system always responds with the latest data, and every request gets a response, but it may not be able to deal with network issues.
- Consistency + Partition Tolerance:
  - If the system responds with data from a distributed store, it is always the latest; otherwise, the data request is dropped.
- Availability + Partition Tolerance:
  - The system always sends and responds based on the distributed store, but the data may not be the absolute latest.

CAP in Reality

- What it is really saying:
  - If you cannot limit the number of faults, requests can be directed to any server, and you insist on serving every request, then you cannot possibly be consistent.
- But it is interpreted as:
  - You must always give up something: consistency, availability, or tolerance to failure.