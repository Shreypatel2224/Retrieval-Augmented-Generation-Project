126 BTrees 1261 BTrees This module presents the Btree Btrees are usually attributed to R Bayer and E McCreight who described the Btree in a 1972 paper By 1979 Btrees had replaced virtually all largefile access methods other than hashing Btrees or some variant of Btrees are the standard file organization for applications requiring insertion deletion and key range searches They are used to implement most modern file systems Btrees address effectively all of the major problems encountered when implementing diskbased search trees 1 The Btree is shallow in part because the tree is always height balanced all leaf nodes are at the same level and in part because the branching factor is quite high So only a small number of disk blocks are accessed to reach a given record 2 Update and search operations affect only those disk blocks on the path from the root to the leaf node containing the query record The fewer the number of disk blocks affected during an operation the less disk IO is required 3 Btrees keep related records that is records with similar key values on the same disk block which helps to minimize disk IO on range searches 4 Btrees guarantee that every node in the tree will be full at least to a certain minimum percentage This improves space efficiency while reducing the typical number of disk fetches necessary during a search or update operation A Btree of order is defined to have the following shape properties The root is either a leaf or has at least two children Each internal node except for the root has between and children All leaves are at the same level in the tree so the tree is always height balanced The Btree is a generalization of the 23 tree Put another way a 23 tree is a Btree of order three Normally the size of a node in the B tree is chosen to fill a disk block A Btree node implementation typically allows 100 or more children Thus a Btree node is equivalent to a disk block and a “pointer” value stored in the tree is actually the number of the block containing the child node usually interpreted as an offset from the beginning of the corresponding disk file In a typical application the Btree’s access to the disk file will be managed using a buffer pool and a blockreplacement scheme such as LRU Figure 1261 shows a Btree of order four Each node contains up to three keys and internal nodes have up to four children Figure 1261 A Btree of order four Search in a Btree is a generalization of search in a 23 tree It is an alternating twostep process beginning with the root node of the B tree 1 Perform a binary search on the records in the current node If a record with the search key is found then return that record If the current node is a leaf node and the key is not found then report an unsuccessful searchm ⌈m2⌉ m 24 1520 334548 1012 18 2123 3030 38 47 50526031425 441 PM 126 BTrees — CS3 Data Structures  Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 192 Otherwise follow the proper branch and repeat the process For example consider a search for the record with key value 47 in the tree of Figure 1261 The root node is examined and the second right branch taken After examining the node at level 1 the third branch is taken to the next level to arrive at the leaf node containing a record with key value 47 Btree insertion is a generalization of 23 tree insertion The first step is to find the leaf node that should contain the key to be inserted space permitting If there is room in this node then insert the key If there is not then split the node into two and promote the middle key to the parent If the parent becomes full then it is split in turn and its middle key promoted Note that this insertion process is guaranteed to keep all nodes at least half full For example when we attempt to insert into a full internal node of a Btree of order four there will now be five children that must be dealt with The node is split into two nodes containing two keys each thus retaining the Btree property The middle of the five children is promoted to its parent 12611 B Trees The previous section mentioned that Btrees are universally used to implement largescale diskbased systems Actually the Btree as described in the previous section is almost never implemented What is most commonly implemented is a variant of the Btree called the tree When greater efficiency is required a more complicated variant known as the tree is used Consider again the linear index When the collection of records will not change a linear index provides an extremely efficient way to search The problem is how to handle those pesky inserts and deletes We could try to keep the core idea of storing a sorted array based list but make it more flexible by breaking the list into manageable chunks that are more easily updated How might we do that First we need to decide how big the chunks should be Since the data are on disk it seems reasonable to store a chunk that is the size of a disk block or a small multiple of the disk block size If the next record to be inserted belongs to a chunk that hasn’t filled its block then we can just insert it there The fact that this might cause other records in that chunk to move a little bit in the array is not important since this does not cause any extra disk accesses so long as we move data within that chunk But what if the chunk fills up the entire block that contains it We could just split it in half What if we want to delete a record We could just take the deleted record out of the chunk but we might not want a lot of nearempty chunks So we could put adjacent chunks together if they have only a small amount of data between them Or we could shuffle data between adjacent chunks that together contain more data The big problem would be how to find the desired chunk when processing a record with a given key Perhaps some sort of treelike structure could be used to locate the appropriate chunk These ideas are exactly what motivate the tree The tree is essentially a mechanism for managing a sorted arraybased list where the list is broken into chunks The most significant difference between the tree and the BST or the standard Btree is that the tree stores records only at the leaf nodes Internal nodes store key values but these are used solely as placeholders to guide the search This means that internal nodes are significantly different in structure from leaf nodes Internal nodes store keys to guide the search associating each key with a pointer to a child tree node Leaf nodes store actual records or else keys and pointers to actual records in a separate disk file if the tree is being used purely as an index Depending on the size of a record as compared to the size of a key a leaf node in a tree of order might have enough room to store more or less than records The requirement is simply that the leaf nodes store enough records to remain at least half full The leaf nodes of a tree are normally linked together to form a doubly linked list Thus the entire collection of records can be traversed in sorted order by visiting all the leaf nodes on the linked list Here is a Javalike pseudocode representation for the tree node interface Leaf node and internal node subclasses would implement this interface  Interface for B Tree nodes  public interface BPNodeKeyE  public boolean isLeaf public int numrecs public Key keys  An important implementation detail to note is that while Figure 1261 shows internal nodes containing three keys and four pointers class BPNode is slightly different in that it stores keypointer pairs Figure 1261 shows the tree as it is traditionally drawn To simplify implementation in practice nodes really do associate a key with each pointer Each internal node should be assumed to hold in theBB∗ BB BB BB Bm m B B B31425 441 PM 126 BTrees — CS3 Data Structures  Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 29leftmost position an additional key that is less than or equal to any possible key value in the node’s leftmost subtree tree implementations typically store an additional dummy record in the leftmost leaf node whose key value is less than any legal key value Let’s see in some detail how the simplest tree works This would be the “ tree” or a tree of order 3 Figure 1262 An example of building a tree Next let’s see how to search Figure 1263 An example of searching a tree Finally let’s see an example of deleting from the treeB B2−3B 1  28     Example 23 Tree V isualization Insert 2−3 1  10     Example 23 Tree V isualization Search 15 J22 X52 B33 65 S71 W89 M7146 65 33 O46 H47 L52 2−3 2−3 1  3331425 441 PM 126 BTrees — CS3 Data Structures  Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 39Figure 1264 An example of deleting from a tree Now let’s extend these ideas to a tree of higher order trees are exceptionally good for range queries Once the first record in the range has been found the rest of the records with keys in the range can be accessed by sequential processing of the remaining records in the first node and then continuing down the linked list of leaf nodes as far as necessary Figure illustrates the tree Figure 1265 An example of search in a B tree of order four Internal nodes must store between two and four children Search in a tree is nearly identical to search in a regular Btree except that the search must always continue to the proper leaf node Even if the searchkey value is found in an internal node this is only a placeholder and does not provide access to the actual record Here is a pseudocode sketch of the tree search algorithm private E findhelpBPNodeKeyE rt Key k  int currec  binarylertkeys rtnumrecs k if rtisLeaf  if BPLeafKeyErtkeyscurrec  k     Example 23 Tree V isualization Delete 22 7146 65 51 2−3 B B B 1  10     Example B Tree V isualization Search in a tree of degree 4 10 S18 E40 Q55 F25 40 77 A89 B98 A127 V25 T39 F9877 B B31425 441 PM 126 BTrees — CS3 Data Structures  Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 49 return BPLeafKeyErtrecscurrec  else  return null   else return findhelpBPInternalKeyErtpointerscurrec k   tree insertion is similar to Btree insertion First the leaf that should contain the record is found If is not full then the new record is added and no other tree nodes are affected If is already full split it in two dividing the records evenly among the two nodes and promote a copy of the leastvalued key in the newly formed right node As with the 23 tree promotion might cause the parent to split in turn perhaps eventually leading to splitting the root and causing the tree to gain a new level tree insertion keeps all leaf nodes at equal depth Figure illustrates the insertion process through several examples Figure 1266 An example of building a B tree of order four Here is a a Javalike pseudocode sketch of the tree insert algorithm private BPNodeKeyE inserthelpBPNodeKeyE rt Key k E e  BPNodeKeyE retval if rtisLeaf   At leaf node insert here return BPLeafKeyErtaddk e   Add to internal node int currec  binarylertkeys rtnumrecs k BPNodeKeyE temp  inserthelp BPInternalKeyErootpointerscurrec k e if temp  BPInternalKeyErtpointerscurrec  return BPInternalKeyErt addBPInternalKeyEtemp  else return rt  BL L BL BB 1  42     Example B Tree V isualization Insert into a tree of degree 4 B31425 441 PM 126 BTrees — CS3 Data Structures  Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 59Here is an exercise to see if you get the basic idea of tree insertion To delete record from the tree first locate the leaf that contains  If is more than half full then we need only remove  leaving still at least half full This is demonstrated by Figure B B Tree Insertion Instructions In this exercise your job is to insert the values from the stack to the B tree Search for the leaf node where the topmost value of the stack should be inserted and click on that node The exercise will take care of the rest Continue this procedure until you have inserted all the values in the stack Undo Reset Model Answer Grade 154318308136963382726775587355356680 R BL RL R L 1  23     Example B Tree V isualization Delete from a tree of degree 4 12 44 675831425 441 PM 126 BTrees — CS3 Data Structures  Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 69Figure 1267 An example of deletion in a B tree of order four If deleting a record reduces the number of records in the node below the minimum threshold called an underflow then we must do something to keep the node sufficiently full The first choice is to look at the node’s adjacent siblings to determine if they have a spare record that can be used to fill the gap If so then enough records are transferred from the sibling so that both nodes have about the same number of records This is done so as to delay as long as possible the next time when a delete causes this node to underflow again This process might require that the parent node has its placeholder key value revised to reflect the true first key value in each node If neither sibling can lend a record to the underfull node call it  then must give its records to a sibling and be removed from the tree There is certainly room to do this because the sibling is at most half full remember that it had no records to contribute to the current node and has become less than half full because it is underflowing This merge process combines two subtrees of the parent which might cause it to underflow in turn If the last two children of the root merge together then the tree loses a level Here is a Javalike pseudocode for the tree delete algorithm  Delete a record with the given key value and return true if the root underflows  private boolean removehelpBPNodeKeyE rt Key k  int currec  binarylertkeys rtnumrecs k if rtisLeaf  if BPLeafKeyErtkeyscurrec  k  return BPLeafKeyErtdeletecurrec  else  return false   else  Process internal node if removehelpBPInternalKeyErtpointerscurrec k   Child will merge if necessary return BPInternalKeyErtunderflowcurrec  else  return false    The tree requires that all nodes be at least half full except for the root Thus the storage utilization must be at least 50 This is satisfactory for many implementations but note that keeping nodes fuller will result both in less space required because there is less empty space in the disk file and in more efficient processing fewer blocks on average will be read into memory because the amount of information in each block is greater Because Btrees have become so popular many algorithm designers have tried to improve Btree performance One method for doing so is to use the tree variant known as the tree The tree is identical to the tree except for the rules used to split and merge nodes Instead of splitting a node in half when it overflows the tree gives some records to its neighboring sibling if possible If the sibling is also full then these two nodes split into three Similarly when a node underflows it is combined with its two siblings and the total reduced to two nodes Thus the nodes are always at least two thirds full 1 Finally here is an example of building a B Tree of order five You can compare this to the example above of building a tree of order four with the same records5 F10 S44 Q48 E67 A88 B58 A60 F12 V27 T N N N B B BB∗B∗B B∗ 1  33     Example B Tree V isualization Insert into a tree of degree 531425 441 PM 126 BTrees — CS3 Data Structures  Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 79Figure 1268 An example of building a B tree of degree 5 Click here for a visualization that will let you construct and interact with a tree This visualization was written by David Galles of the University of San Francisco as part of his Data Structure Visualizations package 1 This concept can be extended further if higher space utilization is required However the update routines become much more complicated I once worked on a project where we implemented 3for4 node split and merge routines This gave better performance than the 2for3 node split and merge routines of the tree However the spitting and merging routines were so complicated that even their author could no longer understand them once they were completed 12612 BTree Analysis The asymptotic cost of search insertion and deletion of records from Btrees trees and trees is where is the total number of records in the tree However the base of the log is the average branching factor of the tree Typical database applications use extremely high branching factors perhaps 100 or more Thus in practice the Btree and its variants are extremely shallow As an illustration consider a tree of order 100 and leaf nodes that contain up to 100 records A B tree with height one that is just a single leaf node can have at most 100 records A tree with height two a root internal node whose children are leaves must have at least 100 records 2 leaves with 50 records each It has at most 10000 records 100 leaves with 100 records each A tree with height three must have at least 5000 records two secondlevel nodes with 50 children containing 50 records each and at most one million records 100 secondlevel nodes with 100 full children each A tree with height four must have at least 250000 records and at most 100 million records Thus it would require an extremely large database to generate a tree of more than height four The tree split and insert rules guarantee that every node except perhaps the root is at least half full So they are on average about 34 full But the internal nodes are purely overhead since the keys stored there are used only by the tree to direct search rather than store actual data Does this overhead amount to a significant use of space No because once again the high fanout rate of the tree structure means that the vast majority of nodes are leaf nodes A Kary tree has approximately of its nodes as internal nodes This means that while half of a full binary tree’s nodes are internal nodes in a tree of order 100 probably only about of its nodes are internal nodes This means that the overhead associated with internal nodes is very low We can reduce the number of disk fetches required for the Btree even more by using the following methods First the upper levels of the tree can be stored in main memory at all times Because the tree branches so quickly the top two levels levels 0 and 1 require relatively little space If the Btree is only height four then at most two disk fetches internal nodes at level two and leaves at level three are required to reach the pointer to any given record A buffer pool could be used to manage nodes of the Btree Several nodes of the tree would typically be in main memory at one time The most straightforward approach is to use a standard method such as LRU to do node replacement However sometimes it might be desirable to “lock” certain nodes such as the root into the buffer pool In general if the buffer pool is even of modest size say at least twice the depth of the tree no special techniques for node replacement will be required because the upperlevel nodes will naturally be accessed frequentlyB B∗ BB∗Θlogn n BB B B B B B 1K B17531425 441 PM 126 BTrees — CS3 Data Structures  Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 8931425 441 PM 126 BTrees — CS3 Data Structures  Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 99