B Tree Walkthrough B Tree m  4  Insert 42 21 63 89  Initially the first node is a leaf node AND root node  21 42 … represent keys of some set of KV pairs  Leaf nodes store keys and data although data is not shown  Inserting another key will cause the node to split B Tree m  4  Insert 35  Leaf node needs to split to accommodate 35  New leaf node allocated to the right of the existing node  52 values stay in the original node remaining values are moved to the new node  The smallest value from the new leaf node 42 is copied up to the parent which needs to be created in this case It will be an internal node B Tree m  4  Insert 10 27 96  The insert process starts at the root node  The keys of the root node are searched to determine which child node to descend to  Example 10 Since 10  42 we follow the pointer to the left of 42  Note None of these new values cause a node to split B Tree m  4  Insert 30  Starting at the root we descend to the leftmost child we’ll call it curr  curr is a leaf node Thus we insert 30 into curr  BUT curr is full So we have to split  Create a new node to the right of curr temporarily called newNode  Insert newNode into the doubly linked list of leaf nodes B Tree m  4  Insert 30 continued  Redistribute the keys  Copy the smallest key 27 in this case from newNode to the parent  Rearrange keys and pointers in the parent node  The parent of newNode is also the root So nothing else needs to be done B Tree m  4  Fast forward to this state of the tree…  Observation The root node is full  The next insertion that splits a leaf will cause the root to split and thus the tree will get 1 level deeper B Tree m  4  Insert 37 Step 1  Insert 37 into the appropriate leaf node B Tree m  4  Insert 37 Step 2  When splitting an internal node we move the middle element to the parent instead of copying it  In this particular tree that means we have to create a new internal node which is also now the root