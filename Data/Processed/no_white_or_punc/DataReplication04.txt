Replicating Data Distributing Data  Benefits  Scalability  High throughput Data volume or ReadWrite load grows beyond the capacity of a single machine  Fault Tolerance  High Availability Your application needs to continue working even if one or more machines go down  Latency When you have users in different parts of the world you want to give them fast performance too Distributed Data  Challenges  Consistency Updates must be propagated across the network  Application Complexity Responsibility for reading and writing data in a distributed environment often falls to the application Vertical Scaling  Shared Memory Architectures  Geographically centralized server  Some fault tolerance via hotswappable components Vertical Scaling  Shared Disk Architectures  Machines are connected via a fast network  Contention and the overhead of locking limit scalability highwrite volumes but are okay for Data Warehouse applications high read volumes AWS EC2 Pricing  Oct 2024  Over 78000month for highperformance instances Horizontal Scaling  Shared Nothing Architectures  Each node has its own CPU memory and disk  Coordination via application layer using conventional network  Geographically distributed  Commodity hardware Data  Replication vs Partitioning  Replicates have the same data as the main node  Partitions have a subset of the data Replication Common Strategies for Replication  Single leader model  Multiple leader model  Leaderless model  Distributed databases usually adopt one of these strategies LeaderBased Replication  All writes from clients go to the leader  Leader sends replication info to the followers  Followers process the instructions from the leader  Clients can read from either the leader or followers LeaderBased Replication  Very Common Strategy  Relational MySQL Oracle SQL Server PostgreSQL  NoSQL MongoDB RethinkDB realtime web apps Espresso LinkedIn  Messaging Brokers Kafka RabbitMQ How Is Replication Info Transmitted to Followers  Replication Methods  Statementbased Send INSERT UPDATE DELETEs to replica Simple but errorprone  Writeahead Log WAL A bytelevel specific log of every change to the database  Logical rowbased Log For relational DBs logs inserted rows modified rows before and after deleted rows  Triggerbased Changes are logged to a separate table whenever a trigger fires Synchronous vs Asynchronous Replication  Synchronous Leader waits for a response from the follower  Asynchronous Leader doesn’t wait for confirmation What Happens When the Leader Fails  Challenges  How do we pick a new Leader Node Consensus strategy or use a controller node  How do we configure clients to start writing to the new leader  If asynchronous replication is used the new leader may not have all the writes  How do we recover the lost writes Or do we simply discard them  After if the old leader recovers how do we avoid having multiple leaders receiving conflicting data Split brain issue  Leader failure detection Optimal timeout is tricky Replication Lag  Replication Lag refers to the time it takes for writes on the leader to be reflected on all of the followers  Synchronous replication Replication lag causes writes to be slower and the system to be more brittle as the number of followers increases  Asynchronous replication Maintains availability but at the cost of delayed or eventual consistency This delay is called the inconsistency window ReadafterWrite Consistency  Scenario You’re adding a comment to a Reddit post After you click Submit and are back at the main post your comment should show up for you  Less important for other users to see your comment immediately Implementing ReadAfterWrite Consistency  Method 1 Modifiable data from the client’s perspective is always read from the leader  Method 2 Dynamically switch to reading from the leader for “recently updated” data For example have a policy that all requests within one minute of the last update come from the leader But… This Can Create Its Own Challenges  Followers were created to be proximal to users but now we have to route requests to distant leaders when reading modifiable data Monotonic Read Consistency  Monotonic read anomalies Occur when a user reads values out of order from multiple followers  Monotonic read consistency Ensures that when a user makes multiple reads they will not read older data after previously reading newer data Consistent Prefix Reads  Reading data out of order can occur if different partitions replicate data at different rates There is no global write consistency  Consistent Prefix Read Guarantee Ensures that if a sequence of writes happens in a certain order anyone reading those writes will see them appear in the same order