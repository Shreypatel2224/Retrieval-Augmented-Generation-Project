Distributed DBs ACID Pessimistic Concurrency ACID Transactions Focuses “data safety” Considered pessimistic concurrency model assumes one transaction protect transactions Assumes something go wrong Conflicts prevented locking resources transaction complete read write locks Write Lock Analogy Borrowing book library one else Optimistic Concurrency Transactions obtain locks data read write Optimistic assumes conflicts unlikely occur Even conflict everything still OK Add last update timestamp version number columns every table Read changing check end transaction see transaction caused modified Optimistic Concurrency Use Cases Low Conflict Systems eg backups analytical DBs readheavy systems Conflicts arise handled rolling back rerunning transaction notices conflict Optimistic concurrency works well allowing higher concurrency High Conflict Systems Rolling back rerunning transactions encounter conflict less efficient locking scheme pessimistic model might preferable NoSQL “NoSQL” first used 1998 Carlo Strozzi describe relational database system use SQL Modern meaning “Not SQL” Sometimes thought nonrelational DBs Originally developed part response processing unstructured webbased data CAP Theorem Review 2 3 following Consistency Every user DB identical view data given instant Availability event failure database system remains operational Partition Tolerance database maintain operations event network’s failing two segments distributed system Note definition Consistency CAP different ACID CAP Theorem Review Continued Consistency Availability System always responds latest data every request gets response may able deal network partitions Consistency Partition Tolerance system responds data distributed system always latest otherwise data request dropped Availability Partition Tolerance System always sends responds based distributed store data may absolute latest ACID Alternative Distributed Systems BASE Basically Available Guarantees availability data per CAP response “failure”“unreliable” data inconsistent changing state system appears work time Soft State state system could change time even without input Changes could result eventual consistency Data stores don’t writeconsistent Replicas don’t mutually consistent Eventual Consistency system eventually become consistent writes eventually stop nodesreplicas updated Categories NoSQL DBs Review KeyValue Databases KeyValue Stores Key Value Designed around Simplicity data model extremely simple Comparatively tables RDBMS complex Lends simple CRUD operations API creation Speed Usually deployed inmemory DB Retrieving value given key typically O1 operation hash tables similar data structures used hood concept complex queries joins—they slow things Scalability Horizontal scaling simple—add nodes Typically concerned eventual consistency meaning distributed environment guarantee nodes eventually converge value Value arbitrary data string number JSON object binary object etc KeyValue Stores Use Cases EDAExperimentation Results Store Store intermediate results data preprocessing EDA Store experiment testing AB results without production DB Feature Store Store frequently accessed features lowlatency retrieval model training prediction Model Monitoring Store key metrics performance model example realtime inferencing KeyValue Stores Software Engineering Use Cases Storing Session Information Everything current session stored via single PUT POST retrieved single GET—very fast User Profiles Preferences User info could obtained single GET operation—language timezone product UI preferences Shopping Cart Data Cart data tied user Needs available across browsers machines sessions Caching Layer front diskbased database Redis DB Redis Remote Directory Server Opensource inmemory database Sometimes called data structure store Primarily keyvalue store used models Graph Spatial Full Text Search Vector Time Series dbenginescom Ranking KeyValue Stores Redis Features Considered inmemory database system Supports durability data Saving snapshots disk specific intervals Using appendonly file journal changes used rollforward failure Originally developed 2009 C fast—over 100000 SET operations per second Rich collection commands handle complex data secondary indexes supports lookup key Redis Data Types Keys Usually strings binary sequence Values Strings Lists linked lists Sets unique unsorted string elements Sorted Sets Hashes string → string Geospatial data Setting Redis Docker Docker Desktop search Redis PullRun latest image Optional Settings Add 6379 Ports expose port connect Normally would expose Redis port security reasons production environment would major security hole Notice didn’t set password Connecting DataGrip File New Data Source Redis Give Data Source name Make sure port 6379 Test connection Redis Database Interaction Redis provides 16 databases default numbered 0 15 name associated Direct interaction Redis set commands related setting getting keyvalue pairs variations Many language libraries available well Foundation Data Type String Sequence bytes text serialized objects binary arrays Simplest data type Maps string another string Use Cases Caching frequently accessed HTMLCSSJS fragments Config settings user settings info token management Counting web pageapp screen views rate limiting Initial Basic Commands SET pathtoresource 0 SET user1 “John Doe” GET pathtoresource EXISTS user1 DEL user1 KEYS user SELECT 5 select different database Basic Commands SET someValue 0 INCR someValue Increment 1 INCRBY someValue 10 Increment 10 DECR someValue Decrement 1 DECRBY someValue 5 Decrement 5 INCR parses value integer increments adds value SETNX key value sets value key key already exist Hash Type Value keyvalue entry collection fieldvalue pairs Use Cases used represent basic objectsstructures number fieldvalue pairs per hash 2321 Practical limit Available system resources eg memory Session information management UserEvent tracking could include TTL Active Session Tracking sessions one hash key Hash Commands HSET bike1 model Demios brand Ergonom price 1971 HGET bike1 model HGET bike1 price HGETALL bike1 HMGET bike1 model price weight HINCRBY bike1 price 100 List Type Value keyvalue pair linked list string values Use Cases Implementation stacks queues Queue management message passing queues producerconsumer model Logging systems easy keep chronological order Building social media streamsfeeds Message history chat application Batch processing queuing set tasks executed sequentially later time Linked Lists Crash Course Sequential data structure linked nodes instead contiguously allocated memory node points next element list except last one points nilnull O1 insert new value front insert new value end List Commands Queue Queuelike Operations LPUSH bikesrepairs bike1 LPUSH bikesrepairs bike2 RPOP bikesrepairs RPOP bikesrepairs List Commands Stack Stacklike Operations LPUSH bikesrepairs bike1 LPUSH bikesrepairs bike2 LPOP bikesrepairs LPOP bikesrepairs List Commands Others List Operations LLEN mylist LRANGE key start stop LRANGE mylist 0 3 LRANGE mylist 0 0 LRANGE mylist 2 1 JSON Type Full support JSON standard Uses JSONPath syntax parsingnavigating JSON document Internally stored binary tree structure fast access subelements Set Type Unordered collection unique strings members Use Cases Tracking unique items eg IP addresses visiting site page screen Primitive relation eg set students DS4300 Access control lists users permission structures Social network friends lists andor group membership Supports set operations Set Commands SADD ds4300 “Mark” SADD ds4300 “Sam” SADD cs3200 “Nick” SADD cs3200 “Sam” SISMEMBER ds4300 “Mark” SISMEMBER ds4300 “Nick” SCARD ds4300 Set Commands Continued SADD ds4300 “Mark” SADD ds4300 “Sam” SADD cs3200 “Nick” SADD cs3200 “Sam” SCARD ds4300 SINTER ds4300 cs3200 SDIFF ds4300 cs3200 SREM ds4300 “Mark” SRANDMEMBER ds4300