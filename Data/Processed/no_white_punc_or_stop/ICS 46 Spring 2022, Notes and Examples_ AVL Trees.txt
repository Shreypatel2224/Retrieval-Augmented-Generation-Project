ICS 46 Spring 2022 News Course Reference Schedule Project Guide Notes Examples Reinforcement Exercises Grade Calculator Alex ICS 46 Spring 2022 Notes Examples AVL Trees must care binary search tree balancing Weve seen previously performance characteristics binary search trees vary rather wildly theyre mainly dependent shape tree height tree key determining factor definition binary search trees restrict keys allowed present nodes — smaller keys left subtrees larger keys right subtrees — specify restriction trees shape meaning perfectly legal binary search trees containing keys 1 2 3 4 5 6 7 Yet legal one better height first tree called perfect binary tree smaller height second called degenerate tree two shapes represent two extremes — best worst possible shapes binary search tree containing seven keys course small number keys like shape number keys grows distinction two tree shapes becomes increasingly vital Whats degenerate shape isnt even necessarily rare edge case get start empty tree add keys already order surprisingly common scenario realworld programs example one obvious algorithm generating unique integer keys — care theyre unique — generate sequentially Whats bad degenerate tree anyway looking picture degenerate tree intuition already telling something amiss particular tilt head 45 degrees right look like linked lists perception accident behave like except theyre complicated boot analytical perspective three results give us pause Every time perform lookup degenerate binary search tree take time possible youll reach every node tree youre done n grows heavy burden bear implement lookup recursively might also using memory might end many n frames runtime stack — one every recursive call ways mitigate — example kinds carefullywritten recursion programming languages including C avoid runtime stack growth recurse — still sign potential trouble time take build degenerate tree also prohibitive start empty binary search tree add keys order long take first key add go directly root could think taking single step creating node second key add require look root node take one step right could think taking two steps subsequent key add require one step one total number steps would take add n keys would determined sum 1 2 3 n sum well see several times throughout course equal nn 1 2 total number steps build entire tree would Θn2 Overall n gets large tree would hideously expensive build every subsequent search would painful well general situation need sure avoid else probably consider data structure binary search tree worst31425 439 PM ICS 46 Spring 2022 Notes Examples AVL Trees httpsicsucieduthorntonics46NotesAVLTrees 17case simply much burden bear n might get large find way control trees shape carefully force remain balanced well fine question course importantly whether keeping cost low enough doesnt outweigh benefit Aiming perfection best goal us shoot would maintain perfection words every time insert key binary search tree would ideally still perfect binary tree case wed know height tree would always Θlog n commensurate effect performance However consider goal problem emerges almost immediately following perfect binary trees definition perfect binary trees pictured 1 3 7 15 nodes respectively possible perfect shapes binary trees number nodes problem though lies fact valid perfect binary tree 2 nodes 4 5 6 8 9 10 11 12 13 14 nodes generally impossible us guarantee binary search tree always perfect definition theres simply way represent numbers keys first things first Well need relax definition perfection accommodate every possible number keys might want store Complete binary trees somewhat relaxed notion perfection something called complete binary tree defined follows complete binary tree height h binary tree h 0 left right subtrees empty h 0 one two things true left subtree perfect binary tree height h − 1 right subtree complete binary tree height h − 1 left subtree complete binary tree height h − 1 right subtree perfect binary tree height h − 2 bit mindbending definition actually leads conceptually simple result every level complete binary tree every node could possibly present except last level might missing nodes missing nodes nodes far left possible following complete binary trees Furthermore possible complete binary trees numbers nodes arrangement say 6 keys besides one shown would violate definition Weve seen height perfect binary tree Θlog n stretch see height complete binary tree Θlog n well well accept via intuition proceed complete binary tree would great goal us attain could keep shape binary search trees complete would always binary search trees height Θlog n cost maintaining completeness trouble course need algorithm maintaining completeness go trouble trying figure one consider whether even worth time deduce cost maintaining completeness even havent figured algorithm yet One example demonstrates big problem Suppose binary search tree left — complete definition — wanted insert key 1 would need algorithm would transform tree left tree right31425 439 PM ICS 46 Spring 2022 Notes Examples AVL Trees httpsicsucieduthorntonics46NotesAVLTrees 27The tree right certainly complete would outcome wed want consider would take Every key tree move matter algorithm used would still move every key n keys tree would take Ωn time — moving n keys takes least linear time even best possible algorithm moving work still get done worst case maintaining completeness single insertion requires Ωn time Unfortunately time ought spending maintaining balance means well need come compromise often case learn design algorithms willingness tolerate imperfect result thats still good enough uses often lead algorithm much faster one achieves perfect result would good enough result good balance condition overall goal lookups insertions removals binary search tree require Olog n time every case rather letting degrade worstcase behavior need decide balance condition say need understand shape considered wellenough balanced purposes even perfect good balance condition two properties height binary search tree meeting condition Θlog n takes Olog n time rebalance tree insertions removals words guarantees height tree still logarithmic give us logarithmictime lookups time spent balancing wont exceed logarithmic time would otherwise spend insertion removal tree logarithmic height cost wont outweigh benefit Coming balance condition like tall task stand shoulders giants came us definition helping guide us toward understanding whether weve found looking compromise AVL trees wellknown approaches maintaining binary search trees state nearbalance meets notion good balance condition One called AVL tree well explore Others outside scope course include redblack trees meet definition good splay trees dont always meet definition good meet amortized basis well stick one solution problem AVL trees AVL trees might called nearly balanced binary search trees certainly arent perfectlybalanced possible nonetheless achieve goals weve decided maintaining logarithmic height logarithmic cost makes binary search tree nearly balanced enough considered AVL tree core concept embodied something called AVL property say node binary search tree AVL property heights left right subtrees dif fer 1 words tolerate certain amount imbalance — heights subtrees slightly different — hopes efficiently maintain Since going comparing heights subtrees theres one piece background need consider Recall height tree length longest path definition height tree root node empty subtrees would zero tree thats totally empty maintain clear pattern relative tree heights well say height empty tree 1 means node say childless left child right child would still considered balanced leads us finally definition AVL tree AVL tree binary search tree nodes AVL property binary trees two AVL two not31425 439 PM ICS 46 Spring 2022 Notes Examples AVL Trees httpsicsucieduthorntonics46NotesAVLTrees 37The thing keep mind AVL matter squinting tree deciding whether looks balanced Theres precise definition two trees dont meet definition fail meet least one node marked diagrams dashed square doesnt AVL property AVL trees definition required meet balance condition every operation every time insert remove key every node tree AVL property meet requirement need restructure tree periodically essentially detecting correcting imbalance whenever wherever happens need rearrange tree ways improve shape without losing essential ordering property binary search tree smaller keys toward left larger ones toward right Rotations Rebalancing AVL trees achieved using called rotations used proper times efficiently improve shape tree altering handful pointers kinds rotations first understand work focus attention use first kind rotation called rotation takes tree left turns tree right circle B written single node containing single key triangles T1 T2 T3 written arbitrary subtrees may empty may contain number nodes binary search trees important remember trees — — binary search trees rotation doesnt harm ordering keys nodes subtrees T1 T2 T3 maintain appropriate positions relative keys B keys T1 smaller keys T2 larger smaller B keys T3 larger B Performing rotation would simple matter adjusting pointers — notably constant number pointers matter many nodes tree means rotation would run Θ1 time Bs parent would point used point B right child would B instead root T2 Bs left child would root T2 instead second kind rotation RR rotation makes similar adjustment Note RR rotation mirror image rotation31425 439 PM ICS 46 Spring 2022 Notes Examples AVL Trees httpsicsucieduthorntonics46NotesAVLTrees 47A third kind rotation LR rotation makes adjustment thats slightly complicated LR rotation requires five pointer updates instead three still constant number changes runs Θ1 time Finally RL rotation mirror image LR rotation understand mechanics rotations work one step closer understanding AVL trees rotations arent arbitrary theyre used specifically correct imbalances detected insertions removals insertion algorithm Inserting key AVL tree starts way insertion binary search tree Perform lookup find key already tree youre done keys binary search tree must unique lookup terminates without key found add new node appropriate leaf position lookup ended problem adding new node introduced possibility imbalance example suppose started AVL tree inserted key 35 binary search tree insertion would give us result 31425 439 PM ICS 46 Spring 2022 Notes Examples AVL Trees httpsicsucieduthorntonics46NotesAVLTrees 57But resulting tree AVL tree node containing key 40 AVL property difference heights subtrees 2 left subtree height 1 right subtree — empty — height 1 answer lies following algorithm perform normal insertion process Work way back tree position added node could quite simple insertion done recursively Compare heights left right subtrees node differ 1 choose rotation fix imbalance Note comparing heights left right subtrees would quite expensive didnt already know solution problem node store height ie height subtree rooted cheaply updated every insertion removal unwind recursion rotation chosen considering two links along path node imbalance heading back toward inserted node wondering names RR LR RL come answer mystery two links left perform rotation rooted imbalance two links right perform RR rotation rooted imbalance first link left second right perform LR rotation rooted imbalance first link right second left perform RL rotation rooted imbalance shown one rotations — RR LR RL — correct imbalance brought inserting key case wed perform LR rotation — first two links leading 40 toward 35 Left Right — rooted 40 would correct imbalance tree would rearranged look like Compare diagram describing LR rotation node containing 40 C node containing 30 node containing 35 B empty left subtree node containing 30 T1 empty left subtree node containing 35 T2 empty right subtree node containing 35 T3 empty right subtree node containing 40 T4 rotation see wed expect node B example contained 35 root newlyrotated subtree node example contained 30 left child root newlyrotated subtree node C example contained 40 right child root newlyrotated subtree four subtrees T1 T2 T3 T4 empty still empty Note tree balanced rotation accident single rotation RR LR RL thats necessary correct imbalance introduced insertion algorithm removal algorithm Removals somewhat similar insertions sense would start usual binary search tree removal algorithm find correct imbalances recursion unwinds key difference removals require one rotation correct imbalances still require rotations path back root removal occurred — generally Olog n rotations Asymptotic analysis key question height AVL tree n nodes answer Θlog n certain lookups insertions removals take Olog n time sure Lookups would Olog n theyre binary search tree doesnt AVL property height tree Θlog n lookups run Olog n time Insertions removals despite slightly complicated AVL tree work traversing single path tree — potentially way leaf position way back length longest path —31425 439 PM ICS 46 Spring 2022 Notes Examples AVL Trees httpsicsucieduthorntonics46NotesAVLTrees 67thats height tree — Θlog n know none paths longer insertions removals take Olog n time left key question height AVL tree n nodes youre curious feel free assume want know keep reading height AVL tree n nodes Optional answer revolves around noting many nodes minimum could binary search tree height n still AVL tree turns AVL trees height n ≥ 2 minimum number nodes share similar property AVL tree height h ≥ 2 minimum number nodes consists root node two subtrees one AVL tree height h − 1 minimum number nodes AVL tree height h − 2 minimum number nodes Given observation write recurrence describes number nodes minimum AVL tree height h M0 1 height 0 minimum number nodes 1 root node children M1 2 height 1 minimum number nodes 2 root node one child Mh 1 Mh 1 Mh 2 repeated substitution technique learned previously isnt good way try solve particular recurrence prove something interesting quite easily know sure AVL trees larger heights bigger minimum number nodes AVL trees smaller heights — thats fairly selfexplanatory — means sure 1 Mh − 1 ≥ Mh − 2 Given conclude following Mh ≥ 2Mh 2 use repeated substitution technique determine lower bound recurrence Mh ≥ 2Mh 2 ≥ 22Mh 4 ≥ 4Mh 4 ≥ 42Mh 6 ≥ 8Mh 6 ≥ 2jMh 2j could prove induction j well accept faith let j h2 ≥ 2h2Mh h ≥ 2h2M0 Mh ≥ 2h2 weve shown minimum number nodes present AVL tree height h least 2h2 reality actually gives us something useful work use result figure really interested opposite height AVL tree n nodes Mh ≥ 2h2 log2Mh ≥ h2 2 log2Mh ≥ h Finally see AVL trees height h minimum number nodes height 2 log2n n number nodes tree AVL trees minimum number nodes relationship number nodes height even better though reasons weve seen previously know relationship number nodes height binary tree never better logarithmic ultimately see height AVL tree n nodes Θlog n reality turns bound lower 2 log2n something akin 144 log2n even AVL trees minimum number nodes though proof involved doesnt change asymptotic result31425 439 PM ICS 46 Spring 2022 Notes Examples AVL Trees httpsicsucieduthorntonics46NotesAVLTrees 77