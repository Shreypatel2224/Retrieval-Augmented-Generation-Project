BTrees idea saw earlier putting multiple set list hash table elements together large chunks exploit locality also applied trees Binary search trees good locality given node binary tree probably occupies fraction cache line Btrees way get better locality putting multiple elements tree node Btrees originally invented storing data structures disk locality even crucial memory Accessing disk location takes 5ms 5000000ns Therefore storing tree disk want make sure given disk read effective possible Btrees high branching factor much larger 2 ensures disk reads needed navigate place data stored B trees may also useful inmemory data structures days main memory almost slow relative processor disk drives main memory Btrees first introduced Btree order search tree nonleaf node children actual elements collection stored leaves tree nonleaf nodes contain keys leaf stores number elements maximum number may greater typically less data structure satisfies several invariants 1 Every path root leaf length 2 node n children contains n−1 keys 3 Every node except root least half full 4 elements stored given subtree keys keys parent node either side subtree pointer generalizes BST invariant 5 root least two children leaf example following order5 Btree m5 leaves enough space store 3 data records height tree uniformly every node least half full guaranteed asymptotic performance Olg n n size collection real win constant factors course choose pointers children plus m−1 elements fill cache line highest level memory hierarchy expect get cache hits example accessing large disk database cache lines memory blocks size read disk Lookup Btree straightforward Given node start use simple linear binary search find whether desired element node child31425 442 PM Btrees httpswwwcscornelleducoursescs31102012sprecitationsrec25Btreesrec25html 13pointer follow current node Insertion deletion Btree complicated fact notoriously difficult implement correctly insertion first find appropriate leaf node inserted element falls assuming already tree already room node new element inserted simply Otherwise current leaf already full must split two leaves one acquires new element parent updated contain new key child pointer parent already full process ripples upwards eventually possibly reaching root root split two new root created two children increasing height tree one example effect series insertions first insertion 13 merely affects leaf second insertion 14 overflows leaf adds key internal node third insertion propagates way root Deletion works opposite way element removed leaf leaf becomes empty key removed parent node breaks invariant 3 keys parent node immediate right left sibling reapportioned among invariant 3 satisfied possible parent node combined sibling removing key another level tree possible causing ripple way root root two children combined root deleted new combined node becomes root tree reducing height tree one31425 442 PM Btrees httpswwwcscornelleducoursescs31102012sprecitationsrec25Btreesrec25html 23Further reading Aho Hopcroft Ullman Data Structures Algorithms Chapter 1131425 442 PM Btrees httpswwwcscornelleducoursescs31102012sprecitationsrec25Btreesrec25html 33