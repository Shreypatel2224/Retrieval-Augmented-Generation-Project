126 BTrees 1261 BTrees module presents Btree Btrees usually attributed R Bayer E McCreight described Btree 1972 paper 1979 Btrees replaced virtually largefile access methods hashing Btrees variant Btrees standard file organization applications requiring insertion deletion key range searches used implement modern file systems Btrees address effectively major problems encountered implementing diskbased search trees 1 Btree shallow part tree always height balanced leaf nodes level part branching factor quite high small number disk blocks accessed reach given record 2 Update search operations affect disk blocks path root leaf node containing query record fewer number disk blocks affected operation less disk IO required 3 Btrees keep related records records similar key values disk block helps minimize disk IO range searches 4 Btrees guarantee every node tree full least certain minimum percentage improves space efficiency reducing typical number disk fetches necessary search update operation Btree order defined following shape properties root either leaf least two children internal node except root children leaves level tree tree always height balanced Btree generalization 23 tree Put another way 23 tree Btree order three Normally size node B tree chosen fill disk block Btree node implementation typically allows 100 children Thus Btree node equivalent disk block “pointer” value stored tree actually number block containing child node usually interpreted offset beginning corresponding disk file typical application Btree’s access disk file managed using buffer pool blockreplacement scheme LRU Figure 1261 shows Btree order four node contains three keys internal nodes four children Figure 1261 Btree order four Search Btree generalization search 23 tree alternating twostep process beginning root node B tree 1 Perform binary search records current node record search key found return record current node leaf node key found report unsuccessful searchm ⌈m2⌉ 24 1520 334548 1012 18 2123 3030 38 47 50526031425 441 PM 126 BTrees — CS3 Data Structures Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 192 Otherwise follow proper branch repeat process example consider search record key value 47 tree Figure 1261 root node examined second right branch taken examining node level 1 third branch taken next level arrive leaf node containing record key value 47 Btree insertion generalization 23 tree insertion first step find leaf node contain key inserted space permitting room node insert key split node two promote middle key parent parent becomes full split turn middle key promoted Note insertion process guaranteed keep nodes least half full example attempt insert full internal node Btree order four five children must dealt node split two nodes containing two keys thus retaining Btree property middle five children promoted parent 12611 B Trees previous section mentioned Btrees universally used implement largescale diskbased systems Actually Btree described previous section almost never implemented commonly implemented variant Btree called tree greater efficiency required complicated variant known tree used Consider linear index collection records change linear index provides extremely efficient way search problem handle pesky inserts deletes could try keep core idea storing sorted array based list make flexible breaking list manageable chunks easily updated might First need decide big chunks Since data disk seems reasonable store chunk size disk block small multiple disk block size next record inserted belongs chunk hasn’t filled block insert fact might cause records chunk move little bit array important since cause extra disk accesses long move data within chunk chunk fills entire block contains could split half want delete record could take deleted record chunk might want lot nearempty chunks could put adjacent chunks together small amount data could shuffle data adjacent chunks together contain data big problem would find desired chunk processing record given key Perhaps sort treelike structure could used locate appropriate chunk ideas exactly motivate tree tree essentially mechanism managing sorted arraybased list list broken chunks significant difference tree BST standard Btree tree stores records leaf nodes Internal nodes store key values used solely placeholders guide search means internal nodes significantly different structure leaf nodes Internal nodes store keys guide search associating key pointer child tree node Leaf nodes store actual records else keys pointers actual records separate disk file tree used purely index Depending size record compared size key leaf node tree order might enough room store less records requirement simply leaf nodes store enough records remain least half full leaf nodes tree normally linked together form doubly linked list Thus entire collection records traversed sorted order visiting leaf nodes linked list Javalike pseudocode representation tree node interface Leaf node internal node subclasses would implement interface Interface B Tree nodes public interface BPNodeKeyE public boolean isLeaf public int numrecs public Key keys important implementation detail note Figure 1261 shows internal nodes containing three keys four pointers class BPNode slightly different stores keypointer pairs Figure 1261 shows tree traditionally drawn simplify implementation practice nodes really associate key pointer internal node assumed hold theBB∗ BB BB BB Bm B B B31425 441 PM 126 BTrees — CS3 Data Structures Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 29leftmost position additional key less equal possible key value node’s leftmost subtree tree implementations typically store additional dummy record leftmost leaf node whose key value less legal key value Let’s see detail simplest tree works would “ tree” tree order 3 Figure 1262 example building tree Next let’s see search Figure 1263 example searching tree Finally let’s see example deleting treeB B2−3B 1 28 Example 23 Tree V isualization Insert 2−3 1 10 Example 23 Tree V isualization Search 15 J22 X52 B33 65 S71 W89 M7146 65 33 O46 H47 L52 2−3 2−3 1 3331425 441 PM 126 BTrees — CS3 Data Structures Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 39Figure 1264 example deleting tree let’s extend ideas tree higher order trees exceptionally good range queries first record range found rest records keys range accessed sequential processing remaining records first node continuing linked list leaf nodes far necessary Figure illustrates tree Figure 1265 example search B tree order four Internal nodes must store two four children Search tree nearly identical search regular Btree except search must always continue proper leaf node Even searchkey value found internal node placeholder provide access actual record pseudocode sketch tree search algorithm private E findhelpBPNodeKeyE rt Key k int currec binarylertkeys rtnumrecs k rtisLeaf BPLeafKeyErtkeyscurrec k Example 23 Tree V isualization Delete 22 7146 65 51 2−3 B B B 1 10 Example B Tree V isualization Search tree degree 4 10 S18 E40 Q55 F25 40 77 A89 B98 A127 V25 T39 F9877 B B31425 441 PM 126 BTrees — CS3 Data Structures Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 49 return BPLeafKeyErtrecscurrec else return null else return findhelpBPInternalKeyErtpointerscurrec k tree insertion similar Btree insertion First leaf contain record found full new record added tree nodes affected already full split two dividing records evenly among two nodes promote copy leastvalued key newly formed right node 23 tree promotion might cause parent split turn perhaps eventually leading splitting root causing tree gain new level tree insertion keeps leaf nodes equal depth Figure illustrates insertion process several examples Figure 1266 example building B tree order four Javalike pseudocode sketch tree insert algorithm private BPNodeKeyE inserthelpBPNodeKeyE rt Key k E e BPNodeKeyE retval rtisLeaf leaf node insert return BPLeafKeyErtaddk e Add internal node int currec binarylertkeys rtnumrecs k BPNodeKeyE temp inserthelp BPInternalKeyErootpointerscurrec k e temp BPInternalKeyErtpointerscurrec return BPInternalKeyErt addBPInternalKeyEtemp else return rt BL L BL BB 1 42 Example B Tree V isualization Insert tree degree 4 B31425 441 PM 126 BTrees — CS3 Data Structures Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 59Here exercise see get basic idea tree insertion delete record tree first locate leaf contains half full need remove leaving still least half full demonstrated Figure B B Tree Insertion Instructions exercise job insert values stack B tree Search leaf node topmost value stack inserted click node exercise take care rest Continue procedure inserted values stack Undo Reset Model Answer Grade 154318308136963382726775587355356680 R BL RL R L 1 23 Example B Tree V isualization Delete tree degree 4 12 44 675831425 441 PM 126 BTrees — CS3 Data Structures Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 69Figure 1267 example deletion B tree order four deleting record reduces number records node minimum threshold called underflow must something keep node sufficiently full first choice look node’s adjacent siblings determine spare record used fill gap enough records transferred sibling nodes number records done delay long possible next time delete causes node underflow process might require parent node placeholder key value revised reflect true first key value node neither sibling lend record underfull node call must give records sibling removed tree certainly room sibling half full remember records contribute current node become less half full underflowing merge process combines two subtrees parent might cause underflow turn last two children root merge together tree loses level Javalike pseudocode tree delete algorithm Delete record given key value return true root underflows private boolean removehelpBPNodeKeyE rt Key k int currec binarylertkeys rtnumrecs k rtisLeaf BPLeafKeyErtkeyscurrec k return BPLeafKeyErtdeletecurrec else return false else Process internal node removehelpBPInternalKeyErtpointerscurrec k Child merge necessary return BPInternalKeyErtunderflowcurrec else return false tree requires nodes least half full except root Thus storage utilization must least 50 satisfactory many implementations note keeping nodes fuller result less space required less empty space disk file efficient processing fewer blocks average read memory amount information block greater Btrees become popular many algorithm designers tried improve Btree performance One method use tree variant known tree tree identical tree except rules used split merge nodes Instead splitting node half overflows tree gives records neighboring sibling possible sibling also full two nodes split three Similarly node underflows combined two siblings total reduced two nodes Thus nodes always least two thirds full 1 Finally example building B Tree order five compare example building tree order four records5 F10 S44 Q48 E67 A88 B58 A60 F12 V27 N N N B B BB∗B∗B B∗ 1 33 Example B Tree V isualization Insert tree degree 531425 441 PM 126 BTrees — CS3 Data Structures Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 79Figure 1268 example building B tree degree 5 Click visualization let construct interact tree visualization written David Galles University San Francisco part Data Structure Visualizations package 1 concept extended higher space utilization required However update routines become much complicated worked project implemented 3for4 node split merge routines gave better performance 2for3 node split merge routines tree However spitting merging routines complicated even author could longer understand completed 12612 BTree Analysis asymptotic cost search insertion deletion records Btrees trees trees total number records tree However base log average branching factor tree Typical database applications use extremely high branching factors perhaps 100 Thus practice Btree variants extremely shallow illustration consider tree order 100 leaf nodes contain 100 records B tree height one single leaf node 100 records tree height two root internal node whose children leaves must least 100 records 2 leaves 50 records 10000 records 100 leaves 100 records tree height three must least 5000 records two secondlevel nodes 50 children containing 50 records one million records 100 secondlevel nodes 100 full children tree height four must least 250000 records 100 million records Thus would require extremely large database generate tree height four tree split insert rules guarantee every node except perhaps root least half full average 34 full internal nodes purely overhead since keys stored used tree direct search rather store actual data overhead amount significant use space high fanout rate tree structure means vast majority nodes leaf nodes Kary tree approximately nodes internal nodes means half full binary tree’s nodes internal nodes tree order 100 probably nodes internal nodes means overhead associated internal nodes low reduce number disk fetches required Btree even using following methods First upper levels tree stored main memory times tree branches quickly top two levels levels 0 1 require relatively little space Btree height four two disk fetches internal nodes level two leaves level three required reach pointer given record buffer pool could used manage nodes Btree Several nodes tree would typically main memory one time straightforward approach use standard method LRU node replacement However sometimes might desirable “lock” certain nodes root buffer pool general buffer pool even modest size say least twice depth tree special techniques node replacement required upperlevel nodes naturally accessed frequentlyB B∗ BB∗Θlogn n BB B B B B B 1K B17531425 441 PM 126 BTrees — CS3 Data Structures Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 8931425 441 PM 126 BTrees — CS3 Data Structures Algorithms httpsopendsaservercsvteduODSABooksCS3htmlBTreehtmlid2 99